import json
from typing import Generic, Iterator, Optional
from urllib.parse import urlencode

from requests import Request, Session

from youtube_searcher.constants import SEARCH_KEY, USER_AGENT, SearchModes
from youtube_searcher.models.channels import ChannelModel
from youtube_searcher.models.videos import SimpleChannelModel, ThumbnailModel, VideoModel
from youtube_searcher.query import Query, QueryDict, ResultsIterator
from youtube_searcher.typings import DC, QL, D, Q


class BaseSearch(Generic[Q, QL, DC]):
    model: DC = None
    base_url: str = None
    objects = ResultsIterator()

    def __init__(
        self,
        query: str,
        limit: Optional[int] = 10,
        language: Optional[str] = 'en',
        region: Optional[str] = 'US',
        search_preferences: Optional[str] = None,
        timeout: Optional[int] = None,
        browse_id: str = None
    ):
        self.query = query
        self.limit = limit
        self.language = language
        self.region = region
        self.search_preferences = search_preferences
        self.timeout = timeout
        self.continuation_key = None
        self.estimate_results: Optional[int] = None
        self.browse_id = browse_id
        # The path to the list of items that
        # we are interested in a__b__c
        self.path_to_items: Optional[str] = None

    def full_clean(self, query_dict: QueryDict):
        """A hook function that can be used by subclasses to modify the
        queryset, run checks... before the models are generated by
        the iterator. Full clean can also be used to dynamically
        change or implement `path_to_items`"""
        return query_dict

    def result_generator(self, queryset: QL) -> Iterator[D]:
        """Custom method used to generate the final results
        of a target element within the response data. The target
        value should return a list of dictionnaries containing
        the key, value pairs that should be kept"""
        if isinstance(queryset, QueryDict):
            raise ValueError(
                "Result generator requires a "
                "QueryList of items to iterate"
            )

        # if isinstance(queryset, list):
        #     queryset = QueryList(queryset)

        for item in queryset:
            yield item

    def get_url(self, **query: str):
        encoded_key = urlencode({'key': SEARCH_KEY, **query})
        return f'{self.base_url}?{encoded_key}'

    def get_payload(self, **extra: str):
        """Needs to be implemented by the subclasses in order
        to create the payload that will be used with the request"""
        base_payload = {
            'context': {
                'client': {
                    'clientName': 'WEB',
                    'clientVersion': '2.20210224.06.00',
                    'newVisitorCookie': True
                },
                'user': {
                    'lockedSafetyMode': False
                }
            }
        }
        return base_payload | extra

    def create_request(self, exta_payload: dict[str, str] = {}, url_query: dict[str, str] = {}):
        session = Session()

        payload = self.get_payload(**exta_payload)
        data = json.dumps(payload).encode('utf-8')

        url = self.get_url(**url_query)
        if url is None:
            raise ValueError('url cannot be None')

        params = {
            'method': 'post',
            'url': url,
            'data': data
        }

        request = Request(**params)
        prepared_request = session.prepare_request(request)

        prepared_request.headers.update(**{
            'Content-Type': 'application/json; charset=utf-8',
            'Content-Length': len(data),
            'User-Agent': USER_AGENT
        })

        return session, prepared_request


class ModelsGeneratorMixin:
    """Implements basic generators for common items
    whene creating trying to render the data"""

    def _thumbnails_generator(self, values: list[dict[str, str]]):
        for item in values:
            yield ThumbnailModel(**item)


class Search(BaseSearch):
    def __init__(self, query: str, *, limit: int = 20, **kwargs: str | int):
        super().__init__(query, limit, **kwargs)


class Videos(ModelsGeneratorMixin, BaseSearch):
    """Search videos on YouTube"""

    model = VideoModel
    base_url = 'https://www.youtube.com/youtubei/v1/search'

    def __init__(self, query: str, *, limit: int = 20, **kwargs: str):
        super().__init__(query, limit, search_preferences=SearchModes.videos, **kwargs)
        self.path_to_items = 'contents__twoColumnSearchResultsRenderer__primaryContents__sectionListRenderer__contents'

    def _channel_generator(self, values: dict[str, str]):
        title = values['text']
        channel_id = values['navigationEndpoint']['browseEndpoint']['browseId']
        return SimpleChannelModel(channel_id, title)

    def result_generator(self, queryset: Query) -> Iterator[D]:
        for item in queryset:
            if 'itemSectionRenderer' in item:
                for content in item['itemSectionRenderer']['contents']:
                    value = content.get('videoRenderer', None)

                    if value is None:
                        continue

                    channel = value['ownerText']['runs'][0]
                    thumbnails = self._thumbnails_generator(
                        value['thumbnail']['thumbnails'])

                    yield {
                        'video_id': value['videoId'],
                        'thumbnails': list(thumbnails),
                        'title': value['title']['runs'][0]['text'],
                        'publication_text': value['publishedTimeText']['simpleText'],
                        'duration': value['lengthText']['simpleText'],
                        'view_count_text': value['viewCountText']['simpleText'],
                        'search_key': value['searchVideoResultEntityKey'],
                        'channel': self._channel_generator(channel)
                    }
            elif 'continuationItemRenderer' in item:
                continue

    def get_payload(self, **extra: dict[str, str]):
        payload = super().get_payload(**extra)

        payload['query'] = self.query
        payload['client'] = {
            'hl': self.language,
            'gl': self.region
        }

        if self.search_preferences:
            payload['params'] = self.search_preferences

        if self.continuation_key is not None:
            payload['continuation'] = self.continuation_key
        return payload


class Channels(BaseSearch):
    pass


class Playlists(BaseSearch):
    pass


class ChannelVideos(ModelsGeneratorMixin, BaseSearch):
    """Searches for videos in specific channel in YouTube
    """

    model = VideoModel
    base_url = 'https://www.youtube.com/youtubei/v1/browse'

    def __init__(self, query: str, channel_id: str, **kwargs):
        kwargs.update(**{
            'browse_id': channel_id,
            'search_preferences': 'EgZzZWFyY2g%3D'
        })
        super().__init__(query, **kwargs)

    def full_clean(self, query_dict):
        path = 'contents__twoColumnBrowseResultsRenderer__tabs'
        last_tab = query_dict.filter(path).last()

        if 'expandableTabRenderer' in last_tab:
            self.path_to_items = 'expandableTabRenderer__content__sectionListRenderer__contents'
            return last_tab
        else:
            tab_renderer = last_tab.filter('tabRenderer')
            if 'content' in tab_renderer:
                self.path_to_items = 'content__sectionListRenderer__contents'
                return tab_renderer
            return []

    def get_url(self, **query):
        query.update(**{'prettyPrint': 'false'})
        return super().get_url(**query)

    def result_generator(self, queryset: Query):
        # itemSectionRenderer -> contents[] -> videoRenderer
        for item in queryset:
            if 'gridPlaylistRenderer' in item:
                continue

            if 'itemSectionRenderer' in item:
                for content in item['itemSectionRenderer']['contents']:
                    if 'videoRenderer' in content:
                        video_details = content['videoRenderer']
                        thumbnails = self._thumbnails_generator(
                            video_details['thumbnail']['thumbnails'])

                        description = video_details.get(
                            'descriptionSnippet', None)
                        if description is not None:
                            description = description['runs'][0]['text']

                        yield {
                            'video_id': video_details['videoId'],
                            'thumbnails': list(thumbnails),
                            'title': video_details['title']['runs'][0]['text'],
                            'publication_text': video_details['publishedTimeText']['simpleText'],
                            'duration': video_details['lengthText']['simpleText'],
                            'view_count_text': video_details['viewCountText']['simpleText'],
                            'description': description
                        }

                    if 'playlistRenderer' in content:
                        continue

            if 'continuationItemRenderer' in item:
                # For endless scrolling, not needed here
                continue

    def get_payload(self, **extra):
        payload = super().get_payload(**extra)

        if self.continuation_key is None:
            payload['params'] = self.search_preferences
            payload['browseId'] = self.browse_id
        else:
            payload['continuation'] = self.continuation_key
        return payload


class Custom(BaseSearch):
    pass
